function [ PI, PIgen, Zp, Zc, Rp, Rc, Zpgen, Zcgen, Rpgen, Rcgen ] = ...
    get_pattern_index( tuning_curve_grating,tuning_curve_plaid )
% [ PI, PIgen, Zp, Zc, Rp, Rc, Zpgen, Zcgen, Rpgen, Rcgen ] = ...
%    get_pattern_index( tuning_curve_grating,tuning_curve_plaid )
% compute patterna and component predictions given two tuning curves

%--------------------------------------------------------------------------
% Component neurons: response to plaid is SUM of responses to two
% components presented separately
% The predicted response for the component model was generated by taking
% the sum of two grating tuning curves, each shifted by ...

% preprocess input and ensure input tuning curves are column vectors 
tun_vector=tuning_curve_grating'+ 0.0000001*rand(size(tuning_curve_grating'));
tun_vector_p=tuning_curve_plaid'+ 0.0000001*rand(size(tuning_curve_plaid'));
tun_vector = ensure_is_colum(tun_vector)';
tun_vector_p = ensure_is_colum(tun_vector_p)';
tun_vector_orig=tun_vector;

% set smoothing parameters
angle_step_interp=5;
angle_step_orig=30;
smoothfrac=0.02;
% perform smoothing
[tun_vector,~,~,~,...
    x_vector,~] = interpolate_tc(tun_vector,angle_step_orig,angle_step_interp,smoothfrac); %#ok<ASGLU> 
[tun_vector_p,~,~,~,...
    x_vector_p,~] = interpolate_tc(tun_vector_p,angle_step_orig,angle_step_interp,smoothfrac); %#ok<ASGLU>
tun_vector=tun_vector';
tun_vector_p=tun_vector_p';

% figure;
% plot(tun_vector,'k'); hold on; plot(tun_vector_orig,'--r');
% title('tuning curve - before / after smoothing')
% xticklabels(x_vector)
% xlabel('direction (deg)')
% ylabel('response')
% set(gca,'fontsize',12)

% get shift to apply to get component prediction
plaid_half_angle=60;
angle_shift_to_apply=plaid_half_angle/angle_step_orig;

% set plaid response
Resp_Plaid=tun_vector_p;
Resp_Grat1_raw = circshift(tun_vector',-angle_shift_to_apply)';
Resp_Grat2_raw = circshift(tun_vector',angle_shift_to_apply)';

%------------------- non-canonical indeces --------------------------------
PDSrev_prediction = circshift(tun_vector',-angle_shift_to_apply)';
PDSori_prediction = (PDSrev_prediction +  tun_vector)/2;
%--------------------------------------------------------------------------

% set predictions
Resp_Comp1 = Resp_Grat1_raw; 
Resp_Comp2 = Resp_Grat2_raw; 
CDS_prediction = (Resp_Comp1 + Resp_Comp2)/2;
PDS_prediction = tun_vector; % pattern prediction

%------------------- non-canonical indeces --------------------------------
CDSP1_prediction = Resp_Comp1;
CDSP2_prediction = Resp_Comp2; 
c_predictions{1}= CDS_prediction;
c_predictions{2}= CDSP1_prediction;
c_predictions{3}= CDSP2_prediction;
p_predictions{1}= PDS_prediction;
p_predictions{2}= PDSrev_prediction;
p_predictions{2}= PDSori_prediction;
%--------------------------------------------------------------------------

% 1) calculate correlation of response to CDS, PDS, and correlation between CDS and PDS
rc = corr(Resp_Plaid',CDS_prediction');
rp = corr(Resp_Plaid',PDS_prediction');
rcp = corr(PDS_prediction',CDS_prediction');

%------------------- non-canonical indeces --------------------------------
[rcgen,rcgen_idx] = max([corr(Resp_Plaid',c_predictions{1}'),...
    corr(Resp_Plaid',c_predictions{2}'),...
    corr(Resp_Plaid',c_predictions{3}')]);

[rpgen,rpgen_idx] = max([corr(Resp_Plaid',p_predictions{1}'),...
    corr(Resp_Plaid',p_predictions{2}')]);
rcpgen = corr(p_predictions{rpgen_idx}',c_predictions{rcgen_idx}');
% ----------------------------------------------------------------------------

% 2) calculate partial correlation to make the two predictions independent
Rp = (rp-rc*rcp)/sqrt((1-rc^2)*(1-rcp^2)); % Pattern
Rc = (rc-rp*rcp)/sqrt((1-rp^2)*(1-rcp^2)); % Component

%------------------- non-canonical indeces --------------------------------
Rcgen = (rcgen-rpgen*rcpgen)/sqrt((1-rpgen^2)*(1-rcpgen^2));
Rpgen = (rpgen-rcgen*rcpgen)/sqrt((1-rcgen^2)*(1-rcpgen^2));
% -------------------------------------------------------------------------

% 3) fisher transform them
Zp=0.5*(log((1+Rp)/(1-Rp)))/sqrt(1/(12-3));
Zc=0.5*(log((1+Rc)/(1-Rc)))/sqrt(1/(12-3));

% figure; 
% plot(0:30:330,CDS_prediction./max(Resp_Plaid),'--','color','k');
% hold on; plot(0:30:330,PDS_prediction./max(Resp_Plaid),'-','color','k');
% plot(0:30:330,Resp_Plaid./max(Resp_Plaid),'color',[1,0.25,0],'linewidth',2)
% ylimused=get(gca,'ylim');
% text(15,0.95*ylimused(2),['rc=',num2str(round(rc,2))])
% text(15,0.9*ylimused(2),['rp=',num2str(round(rp,2))])
% text(15,0.85*ylimused(2),['rpc=',num2str(round(rcp,2))])
% title(['Zp and Zc computation diagnostics ( Zp = '...
%     ,num2str(round(Zp,2)),' Zc = ',num2str(round(Zc,2)),' )'])
% legend({'c pred','p pred','p resp'})
% xlabel('direction')
% xlabel('amplitude')

%------------------- non-canonical indeces --------------------------------
Zcgen=0.5*(log((1+Rcgen)/(1-Rcgen)))/sqrt(1/(12-3));
Zpgen=0.5*(log((1+Rpgen)/(1-Rpgen)))/sqrt(1/(12-3));
% -------------------------------------------------------------------------

% 4) compute "pattern index" (Wang, Movshon 2015)
PI=Zp-Zc;

%------------------- non-canonical indeces --------------------------------
PIgen=Zpgen-Zcgen;
% -------------------------------------------------------------------------

end

