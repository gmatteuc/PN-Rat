function [ PI, PIgen, Zp, Zc, Rp, Rc, Zpgen, Zcgen, Rpgen, Rcgen ] = ...
    get_pattern_index( tuning_curve_grating,tuning_curve_plaid )
% [ PI, PIgen, Zp, Zc, Rp, Rc, Zpgen, Zcgen, Rpgen, Rcgen ] = ...
%    get_pattern_index( tuning_curve_grating,tuning_curve_plaid )
% compute patterna and component predictions given two tuning curves

%--------------------------------------------------------------------------
% Component neurons: response to plaid is SUM of responses to two
% components presented separately
% The predicted response for the component model was generated by taking
% the sum of two grating tuning curves, each shifted by ...

% re-assign names
tun_vector=tuning_curve_grating'+ 0.0000001*rand(size(tuning_curve_grating'));
tun_vector_p=tuning_curve_plaid'+ 0.0000001*rand(size(tuning_curve_plaid'));

% ensure input tunin curves are vectors 
tun_vector = ensure_is_colum(tun_vector)';
tun_vector_p = ensure_is_colum(tun_vector_p)';

% % interpolate tuning curve
% x_orig=0:30:330;
% plaid_half_angle=60;
% angle_step=30;
% angle_shift_to_apply=plaid_half_angle/angle_step;
% x_new=0:angle_step:330;% x_new=0:15:330;
% tun_vector=interp1(x_orig,tun_vector,x_new,'spline');
% tun_vector_p=interp1(x_orig,tun_vector_p,x_new,'spline');

% smooth tuning curve
% tun_vector_orig=tun_vector;
% tun_vector_p_orig=tun_vector_p;
% x_orig=0:30:330;
% plaid_half_angle=60;
% angle_step=5;
% angle_shift_to_apply=plaid_half_angle/angle_step;
% x_new=0:angle_step:330;% x_new=0:15:330;
% tun_vector=interp1(x_orig,tun_vector,x_new,'spline');
% tun_vector_p=interp1(x_orig,tun_vector_p,x_new,'spline');

% figure; 
% subplot(1,3,1);
% plot(x_new,tun_vector,'k'); hold on; plot(x_new(1:6:end),tun_vector(1:6:end),'r');
% subplot(1,3,2);
% tun_vector_smooth=smooth(tun_vector,0.5,'loess');
% plot(x_new,tun_vector_smooth,'k'); hold on; plot(x_new(1:6:end),tun_vector_smooth(1:6:end),'r');
% subplot(1,3,3);
% plot(x_new(1:6:end),tun_vector(1:6:end),'r'); hold on; plot(x_new(1:6:end),tun_vector_smooth(1:6:end),'--r');

% set smoothing parameters
angle_step_interp=5;
angle_step_orig=30;
smoothfrac=15;
% perform smoothing
[tun_vector,~,~,~,...
    x_vector,~] = interpolate_tc(tun_vector,angle_step_orig,angle_step_interp,smoothfrac); %#ok<ASGLU>
[tun_vector_p,~,~,~,...
    x_vector_p,~] = interpolate_tc(tun_vector_p,angle_step_orig,angle_step_interp,smoothfrac); %#ok<ASGLU>
% get shift to apply to get component prediction
plaid_half_angle=60;
angle_shift_to_apply=plaid_half_angle/angle_step_orig;


% tun_vector_smooth=smooth(tun_vector,0.5,'loess')';
% tun_vector_p_smooth=smooth(tun_vector_p,0.5,'loess')';
% tun_vector=tun_vector_smooth(1:6:end);
% tun_vector_p=tun_vector_p_smooth(1:6:end);
% tun_vector(1)=tun_vector_orig(1);
% tun_vector(end)=tun_vector_orig(end);
% tun_vector_p(1)=tun_vector_p_orig(1);
% tun_vector_p(end)=tun_vector_p_orig(end);
% angle_shift_to_apply=plaid_half_angle/30;
% 
% tun_vector=tun_vector_orig;
% tun_vector_p=tun_vector_p_orig;

% set plaid response
Resp_Plaid=tun_vector_p;
Resp_Grat1_raw = circshift(tun_vector',-angle_shift_to_apply)';
Resp_Grat2_raw = circshift(tun_vector',angle_shift_to_apply)';

%------------------- non-canonical indeces --------------------------------
PDSrev_prediction = circshift(tun_vector',-angle_shift_to_apply)';
PDSori_prediction = (PDSrev_prediction +  tun_vector)/2;
%--------------------------------------------------------------------------

% set predictions
Resp_Comp1 = Resp_Grat1_raw; 
Resp_Comp2 = Resp_Grat2_raw; 
CDS_prediction = (Resp_Comp1 + Resp_Comp2)/2;
PDS_prediction = tun_vector; % pattern prediction

%------------------- non-canonical indeces --------------------------------
CDSP1_prediction = Resp_Comp1;
CDSP2_prediction = Resp_Comp2; 
c_predictions{1}= CDS_prediction;
c_predictions{2}= CDSP1_prediction;
c_predictions{3}= CDSP2_prediction;
p_predictions{1}= PDS_prediction;
p_predictions{2}= PDSrev_prediction;
p_predictions{2}= PDSori_prediction;
%--------------------------------------------------------------------------


% 1) calculate correlation of response to CDS, PDS, and correlation between CDS and PDS
rc = corr(Resp_Plaid',CDS_prediction');
rp = corr(Resp_Plaid',PDS_prediction');
rcp = corr(PDS_prediction',CDS_prediction');


%------------------- non-canonical indeces --------------------------------
[rcgen,rcgen_idx] = max([corr(Resp_Plaid',c_predictions{1}'),...
    corr(Resp_Plaid',c_predictions{2}'),...
    corr(Resp_Plaid',c_predictions{3}')]);

[rpgen,rpgen_idx] = max([corr(Resp_Plaid',p_predictions{1}'),...
    corr(Resp_Plaid',p_predictions{2}')]);
rcpgen = corr(p_predictions{rpgen_idx}',c_predictions{rcgen_idx}');
% ----------------------------------------------------------------------------


% 2) calculate partial correlation to make the two predictions independent
Rp = (rp-rc*rcp)/sqrt((1-rc^2)*(1-rcp^2)); % Pattern
Rc = (rc-rp*rcp)/sqrt((1-rp^2)*(1-rcp^2)); % Component


%------------------- non-canonical indeces --------------------------------
Rcgen = (rcgen-rpgen*rcpgen)/sqrt((1-rpgen^2)*(1-rcpgen^2));
Rpgen = (rpgen-rcgen*rcpgen)/sqrt((1-rcgen^2)*(1-rcpgen^2));
% -------------------------------------------------------------------------


% 3) fisher transform them
Zp=0.5*(log((1+Rp)/(1-Rp)))/sqrt(1/(12-3));
Zc=0.5*(log((1+Rc)/(1-Rc)))/sqrt(1/(12-3));

% figure; plot(x_new,CDS_prediction./max(Resp_Plaid),'--','color','k');
% hold on; plot(x_new,PDS_prediction./max(Resp_Plaid),'-','color','k');
% plot(x_new,Resp_Plaid./max(Resp_Plaid),'color',[1,0.25,0],'linewidth',2)
% ylimused=get(gca,'ylim');
% text(15,0.95*ylimused(2),['rc=',num2str(round(rc,2))])
% text(15,0.9*ylimused(2),['rp=',num2str(round(rp,2))])
% text(15,0.85*ylimusteaed(2),['rpc=',num2str(round(rcp,2))])
% title(['Zp and Zc computation diagnostics ( Zp = '...
%     ,num2str(round(Zp,2)),' Zc = ',num2str(round(Zc,2)),' )'])
% legend({'c pred','p pred','p resp'})
% xlabel('direction')
% xlabel('amplitude')

%------------------- non-canonical indeces --------------------------------
Zcgen=0.5*(log((1+Rcgen)/(1-Rcgen)))/sqrt(1/(12-3));
Zpgen=0.5*(log((1+Rpgen)/(1-Rpgen)))/sqrt(1/(12-3));
% -------------------------------------------------------------------------


% 4) compute "pattern index" (Wang, Movshon 2015)
PI=Zp-Zc;


%------------------- non-canonical indeces --------------------------------
PIgen=Zpgen-Zcgen;
% -------------------------------------------------------------------------


end

